using BenchmarkTools
using Dates
using Profile

function slowMultiply(polynomial1, polynomial2)
    # Classic, O(n^2) way of multiplying polynomials (FOIL)
    # 
    # Parameter definitions:
    # polynomial1, polynomial2: Arrays containing coefficients of polynomials to be multiplied.
    # 
    # Returns array containing coefficients of product of polynomial1 and polynomial2

    temp = [0 for i in 1:(length(polynomial1) + length(polynomial2)-1)]
    for i in eachindex(polynomial1) 
        for j in eachindex(polynomial2)
            temp[i + j - 1] += polynomial1[i] * polynomial2[j]
        end
    end
    return temp
end

function fastDFT(a, inverted = 1)
    # Parent function to call fastDFThelper, only exists so that this theta array only needs to be calculated once
    #
    # Parameter definition:
    # a: coefficients of polynomial to be evaluated
    # inverted: default to 1, useful in inverseDFT algorithm.
    #
    # Returns coefficients of y, evaluated by Va=y

    theta = [cis(2 * (i - 1) * inverted * pi / length(a)) for i in 1:div(length(a), 2)]
    return fastDFThelper(a, theta, 0, inverted)
end

function fastDFThelper(a, theta, depth = 0, inverted = 1)
    # First step of FFT. Evaluates polynomial with coefficients stored in a at the n roots of unity, where
    # n = 2^ceiling(log_2(final degree of product)). We want n to be a power of 2, because it makes the recursion
    # easy. 
    # 
    # Parameter definition:
    #
    # a: coefficients of polynomial to be evaluated
    # inverted: default to 1, useful when calling fastIDFT() because DFT and IDFT are basically the same algorithm
    # 
    # Returns coefficients of y, evaluated by Va=y

    n = length(a)
    if n == 1 return a
    end

    # Slicing up polynomial for p(x) = p0(x^2) + xp1(x^2)
    a0 = a[1:2:n]
    a1 = a[2:2:n]

    # Recursive step, this is what makes the algorithm nlog(n)
    y0 = fastDFThelper(a0, theta, depth + 1, inverted)
    y1 = fastDFThelper(a1, theta, depth + 1, inverted)

    # Initializing final array
    result = [complex(0.0, 0) for i in 1:n]

    for i in 1:div(n, 2)
        # p(x) = p0(x^2) + xp1(x^2)
        result[i] = y0[i] + theta[(2^depth) * (i - 1) + 1] * y1[i]
        result[i + div(n, 2)] = y0[i] - theta[(2^depth) * (i - 1) + 1] * y1[i]
    end

    return result
# I really don't know why I need 2 'end's here, but it doesn't work otherwise
end


function fastIDFT(y)
    # InverseDFT. DFT is the transformation represented by Va=y, where V is the Vandermonde matrix consisting of 
    # the n roots of unity. IDFT calculates a=V^-1 y, and V^-1 is very easy to calculate.
    # Parameter definition:
    #
    # y: coefficients of vector generated by evaluating polynomial at n roots of unity
    # 
    # Returns array containing coefficients of polynomial that generated y from Va=y

    n = length(y)
    result = fastDFT(y, -1)
    return [result[i] / n for i in eachindex(result)]
end

function fastMultiply(p1, p2)
    # Extremely quick explanation of multiplying polynomials with DFT:
    # Let a and b be arrays that represent the coefficients of the polynomial. Then, the Vandermonde matrix V
    # evaluates a and b at the n roots of unity, where n is the next highest power of 2 of the resulting product degree
    # So, Va = y, and Vb = z. Multiplying the corresponding entries of y and z, to result in vector x, yields the product
    # evaluated at the n roots of unity. Then, our final polynomial, c, can be computed by c = V^-1 z.
    # 
    # Parameter definitions:
    # 
    # polynomial1, polynomial2: Arrays containing coefficients of polynomials to be multiplied. Copies of these arrays are
    # created so that the originals are unchanged.
    #
    # Returns array containing coefficients of product of polynomial1 and polynomial2

    n = Int.(2^ceil(log2(length(p1) + length(p2) - 1)))
    finalLength = length(p1) + length(p2) - 1

    append!(p1, zeros(Int, n - length(p1)))
    append!(p2, zeros(Int, n - length(p2)))

    y1 = fastDFT(p1)
    y2 = fastDFT(p2)

    ans = fastIDFT([y1[i] * y2[i] for i in 1:n])
    return [round(real(ans[i])) for i in 1:finalLength]
end

polynomial1 = [i for i in 1:50]
polynomial2 = [i for i in 1:50]

println("-----------------start------------------")
t = now()
println(slowMultiply(polynomial1, polynomial2))
println(now() - t) #84 ms

t = now()
println(fastMultiply(polynomial1, polynomial2))
println(now() - t) #545 ms

#Recursion doesn't work because Julia doesn't have tail call optimization
println("------------------end-------------------")
